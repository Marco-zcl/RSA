import tkinter as tk
from Crypto.Util.number import *
from gmpy2 import *

class RSADecryptionGUI:
    def __init__(self, master):
        self.master = master
        master.title("RSA基础解密工具")

        self.label_algorithm = tk.Label(master, text="选择解密算法(仅支持10进制):")
        self.label_algorithm.pack()

        self.algorithm_var = tk.StringVar()
        self.algorithm_var.set("RSA1")  # 默认选择RSA算法

        self.algorithm_options = ["RSA1","RSA2", "RSA3","共享素数", "共模攻击", "e过小", "pq接近","e过大的dp泄露(m=getPrime(64))(10007)", "dp泄露", "维纳攻击", "e_phi不互素", "p-1光滑", "p+1光滑", "小明文攻击", "低密度广播攻击", "d泄露攻击","dp&dq泄漏攻击","Rabin算法","16进制转换"]
        self.algorithm_menu = tk.OptionMenu(master, self.algorithm_var, *self.algorithm_options, command=self.show_algorithm_params)
        self.algorithm_menu.pack()

        self.algorithm_params = {}
        self.params_labels = []
        self.params_entries = []

        self.decrypt_button = tk.Button(master, text="解密", command=self.decrypt)
        self.decrypt_button.pack()

        self.output_log = tk.Text(master, height=10, width=40)
        self.output_log.pack()

    def show_algorithm_params(self, algorithm):
        # 清除之前的参数输入
        for label, entry in zip(self.params_labels, self.params_entries):
            label.destroy()
            entry.destroy()

        # 显示新算法的参数输入
        self.algorithm_params = {}
        if algorithm == "16进制转换":
            label = tk.Label(self.master, text="输入16进制数:")
            label.pack()
            entry = tk.Entry(self.master, width=80)  # 设置输入框的宽度为80个字符
            entry.pack()
            self.algorithm_params["hex_number"] = entry
            self.params_labels.append(label)
            self.params_entries.append(entry)
        else:
            params_info = get_algorithm_params_info(algorithm)  # 获取参数信息，具体实现需要根据实际情况
            for param_name, param_type in params_info.items():
                label = tk.Label(self.master, text=f"输入{param_name}:")
                label.pack()
                entry = tk.Entry(self.master, width=80)  # 设置输入框的宽度为80个字符
                entry.pack()
                self.algorithm_params[param_name] = entry
                self.params_labels.append(label)
                self.params_entries.append(entry)

    def decrypt(self):
        try:
            algorithm = self.algorithm_var.get()

            if algorithm == "16进制转换":
                hex_number = self.algorithm_params["hex_number"].get()
                decimal_number = int(hex_number, 16)
                octal_number = oct(decimal_number)
                binary_number = bin(decimal_number)

                # 在输出日志中显示转换结果
                self.output_log.insert(tk.END, f"10进制数: {decimal_number}\n")
                self.output_log.insert(tk.END, f"8进制数: {octal_number}\n")
                self.output_log.insert(tk.END, f"2进制数: {binary_number}\n")

            else:
                # 获取算法参数
                algorithm_params = {}
                for param_name, entry in self.algorithm_params.items():
                    algorithm_params[param_name] = entry.get()

                # 根据选择的算法和参数进行解密
                decrypted_message = decrypt_with_algorithm(algorithm, algorithm_params)

                # 在输出日志中显示解密结果
                self.output_log.insert(tk.END, f"解密后的消息: {decrypted_message}\n")

        except ValueError:
            self.output_log.insert(tk.END, "请输入有效的值\n")

def decrypt_with_algorithm(algorithm, params):
    import gmpy2
    from itertools import count
    import hashlib
    # 根据算法和参数进行解密
    if algorithm == "RSA1":
        c = int(params["c"])
        d = int(params["d"])
        n = int(params["n"])
        m = pow(c, d, n)
        decrypted_message = long_to_bytes(m).decode('utf-8'),m
    elif algorithm == "共享素数":
        m1 = int(params["m1"])
        m2 = int(params["m2"])
        c = int(params["c"])
        e = int(params["e"])
        gift = gcd(m1, m2)
        p = m2 // gift
        q = gift // (p + 1)
        n = p * q
        phi = (p - 1) * (q - 1)
        d = invert(e, phi)
        flag = pow(c, d, n)
        decrypted_message = long_to_bytes(flag).decode('utf-8'),flag
    elif algorithm == "RSA2":
        c = int(params["c"])
        e = int(params["e"])
        n = int(params["n"])

        def factorization(n):
            i = 2
            ret = []
            while i * i <= n:
                while n % i == 0:
                    ret.append(i)
                    n //= i
                i += 1
            if n > 1:
                ret.append(n)
            return ret

        p = factorization(n)[0]
        q = factorization(n)[1]
        d = inverse(e, (p - 1) * (q - 1))
        m = pow(c, d, n)
        decrypted_message = long_to_bytes(m),m
    elif algorithm == "共模攻击":
        # 实现其他算法2的解密逻辑
        c1 = int(params["c1"])
        c2 = int(params["c2"])
        e1 = int(params["e1"])
        e2 = int(params["e2"])
        n = int(params["n"])
        _, s1, s2 = gcdext(e1, e2)
        m = powmod(c1, s1, n) * powmod(c2, s2, n) % n

        decrypted_message = long_to_bytes(m).decode('utf-8'),m
    elif algorithm == "e过小":
        # 实现其他算法2的解密逻辑
        n = int(params["n"])
        e = int(params["e"])
        c = int(params["c"])
        for k in range(1000000000):
            cc = c + k * n
            res = iroot(cc, e)
            if res[1]:
                m = res[0]
                break

        decrypted_message = long_to_bytes(m).decode('utf-8'),m
    elif algorithm == "pq接近":
        # 实现其他算法2的解密逻辑
        n = int(params["n"])
        e = int(params["e"])
        c = int(params["c"])
        i = gmpy2.iroot(n, 2)[0]
        while not gmpy2.is_prime(i):
            i += 1
        p = i
        q = n // p
        if n == p * q:
            d = inverse(e, (p - 1) * (q - 1))
            m = pow(c, d, n)
        # print(int(m).to_bytes((m.bit_length() + 1) // 8, 'big'))
            print(long_to_bytes(m))
        decrypted_message = long_to_bytes(m).decode('utf-8'),m
    elif algorithm == "e过大的dp泄露(m=getPrime(64))(10007)":
        # 实现其他算法2的解密逻辑
        n = int(params["n"])
        e = int(params["e"])
        c = int(params["c"])
        dp = int(params["dp"])
        m = int(params["m"])
        p = gcd(powmod(m, e * dp, n) - m, n)
        q = n // p
        d = invert(e, (p - 1) * (q - 1))
        m = powmod(c, d, n)
        decrypted_message = long_to_bytes(m).decode('utf-8'),m
    elif algorithm == "dp泄露":
        # 实现其他算法2的解密逻辑
        n = int(params["n"])
        e = int(params["e"])
        c = int(params["c"])
        dp = int(params["dp"])
        for k in range(1, e):
            if (e * dp - 1) % k == 0:
                p = (e * dp - 1) // k + 1
                if n % p == 0:
                    q = n // p
                    d = invert(e, (p - 1) * (q - 1))
                    m = powmod(c, d, n)
                    break
        decrypted_message = long_to_bytes(m).decode('utf-8'),m
    elif algorithm == "维纳攻击":
        # 实现其他算法2的解密逻辑
        n = int(params["n"])
        e = int(params["e"])
        c = int(params["c"])

        class ContinuedFraction():
            def __init__(self, numerator, denumerator):
                self.numberlist = []  # number in continued fraction
                self.fractionlist = []  # the near fraction list
                self.GenerateNumberList(numerator, denumerator)
                self.GenerateFractionList()

            def GenerateNumberList(self, numerator, denumerator):
                while numerator != 1:
                    quotient = numerator // denumerator
                    remainder = numerator % denumerator
                    self.numberlist.append(quotient)
                    numerator = denumerator
                    denumerator = remainder

            def GenerateFractionList(self):
                self.fractionlist.append([self.numberlist[0], 1])
                for i in range(1, len(self.numberlist)):
                    numerator = self.numberlist[i]
                    denumerator = 1
                    for j in range(i):
                        temp = numerator
                        numerator = denumerator + numerator * self.numberlist[i - j - 1]
                        denumerator = temp
                    self.fractionlist.append([numerator, denumerator])

        a = ContinuedFraction(e, n)
        for k, d in a.fractionlist:
            m = powmod(c, d, n)
            flag = long_to_bytes(m)
            if b'flag' or b'ctf'  in flag:
                mw = flag
        decrypted_message = mw
    elif algorithm == "e_phi不互素":
        # 实现其他算法2的解密逻辑
        n = int(params["n"])
        e = int(params["e"])
        c = int(params["c"])
        p = int(params["p"])
        q = int(params["q"])
        phi = (p - 1) * (q - 1)
        t = gcd(e, phi)
        d = invert(e // t, phi)
        M = pow(c, d, n)
        m = gmpy2.iroot(M, t)[0]
        flag = long_to_bytes(m)
        decrypted_message = flag,m
    elif algorithm == "p-1光滑":
        # 实现其他算法2的解密逻辑
        n = int(params["n"])
        e = int(params["e"])
        c = int(params["c"])
        a = 2
        m = 2
        while True:
            a = powmod(a, m, n)
            p = gcd(a - 1, n)
            if p != 1 and p != n:
                break
            m += 1

        q = n // p

        phi = (p - 1) * (q - 1)
        d = invert(e, phi)
        m = powmod(c, d, n)
        decrypted_message = long_to_bytes(m),m
    elif algorithm == "p+1光滑":
        # 实现其他算法2的解密逻辑
        n = int(params["n"])
        e = int(params["e"])
        c = int(params["c"])

        def mlucas(v, a, n):
            v1, v2 = v, (v ** 2 - 2) % n
            for bit in bin(a)[3:]: v1, v2 = ((v1 ** 2 - 2) % n, (v1 * v2 - v) % n) if bit == "0" else (
                (v1 * v2 - v) % n, (v2 ** 2 - 2) % n)
            return v1

        def primegen():
            yield 2
            yield 3
            yield 5
            yield 7
            yield 11
            yield 13
            ps = primegen()  # yay recursion
            p = ps.__next__() and ps.__next__()
            q, sieve, n = p ** 2, {}, 13
            while True:
                if n not in sieve:
                    if n < q:
                        yield n
                    else:
                        next, step = q + 2 * p, 2 * p
                        while next in sieve:
                            next += step
                        sieve[next] = step
                        p = ps.__next__()
                        q = p ** 2
                else:
                    step = sieve.pop(n)
                    next = n + step
                    while next in sieve:
                        next += step
                    sieve[next] = step
                n += 2

        def ilog(x, b):  # greatest integer l such that b**l <= x.
            l = 0
            while x >= b:
                x /= b
                l += 1
            return l

        def attack(n):
            for v in count(1):
                for p in primegen():
                    e = ilog(isqrt(n), p)
                    if e == 0:
                        break
                    for _ in range(e):
                        v = mlucas(v, p, n)
                    g = gcd(v - 2, n)
                    if 1 < g < n:
                        return int(g), int(n // g)  # g|n
                    if g == n:
                        break

        p, q = attack(n)

        phi = (p - 1) * (q - 1)
        d = invert(e, phi)
        m = powmod(c, d, n)
        decrypted_message = long_to_bytes(m),m
    elif algorithm == "小明文攻击":
        # 实现其他算法2的解密逻辑
        n = int(params["n"])
        e = int(params["e"])
        c = int(params["c"])
        m = iroot(c, e)

        decrypted_message = long_to_bytes(m[0]),m
    elif algorithm == "低密度广播攻击":
        # 实现其他算法2的解密逻辑
        hhh = int(params["input number get wp"])

        decrypted_message = """import gmpy2
import libnum
from Crypto.Util.number import *
c1=gmpy2.mpz(6898921523352482316367518398442267634376251850374623680349467966853880304694886901649581738681452045723891540172999820599402445058544662323034765216711209250289878330726838115343609022406763393163140068036299286009515092983919449391495043168525824344854648006979702352215321913848527085843370332472775226427140204969848150525338752667783912712952218153738072859186124678429022054457700638764587316770132066288343288653735386030886970200086778155661564553591240364750111940536912403780751878915390969163712013858340542784964416635799577698531293507044826805530540120328708811859974537858304296139654641997971620581941)
n1=gmpy2.mpz(21778816622407043254249033744556437773178718344170907687035355752306254181495272254316323076827432323583279284697609943296234700945010885010381052459024155936090811012664924674758219163065019349740707282354505096608107707774970709715259835448587834080152409078047162951805940071358655938727249679105305351838950073539149057650448964397736279148746703675407495243942505041731104580156762842345374978325029947055323567120523592936170640156611551704828034384851988154353272897487218723570180022092379408219114849763765186588476489924721044926152006318666687949095907516827647042434514271847608156543261745856327152256691)
c2=gmpy2.mpz(644917346958337353511368628230168709121184047618728491377463145010467190550283777148025911732268676193204746892957938209964091009001499393827852731486194468974232686515969800874573647244111142196026847609398947778020793312974827555577371143016931473280490663570998106844999564031322393565926664764356558877488845992749543497663501930213246984037538497917776416370966705204365508286338995278265185251504894458314847091439946240110992959271288258426621646846816640931166628086735078907446836790148200917845789886605709397229589171507361786224717118572955402542992097341344675408272470020806404190628206096453435062599)
n2=gmpy2.mpz(16903196746534976770297193591563118819340996326353278926932894774572875445074235633598238073286562040907331827987129504332575088363961056320711957070361568300931751447818086187098450831958791194454471761207974960285694400991565796076896861484262801877894234189007108688232929103575715501208714450050820596757093532908538335247758665436735062990069823263343612343383280128868367115993204155509197451034689222789081909649433189803691801997724286399861059723879464142218791577045451380036235131262854852861711356480129365121825413631051962999057782796860262353799309363207995917585708071851074274505668412220771866627801)
c3=gmpy2.mpz(17922535082858613627977737742215131940092523605510219392464552171173547778785785258718665770452746217649406220264502064596122304044693490572463057765265192788378812238587120234863584689048975385894113116360278039772348405278524108871629961875628750068892181741138286885523596910739703331632335212949027589164972724198314766023022056997293021697312078829910692611851974971540109396034374828537545727303346905957931682646875835496892423870609851093161153405239209069568602749544991996550844917100686568329625008855318827589701181436597357755500084155805939091380869199902403397282792407816178315996255973863771199915011)
n3=gmpy2.mpz(28265280613183354342105753166996328090546389493099576671064332905506043149645894359529530572985221453256974871551423452437262179254048995385871426911106523040024082014701860288597240859367709958593683404815121262284405370456892785825244621855179713916387058136808290106777122592782679759913015048141455589449020109912456204732596642195119782747444413318147656712489309539304507463058220125712352312270109971524224764775787216566974066782153169186108327462634247269028163635556628016922590640886497451631819173964909716933392801888324681183442906718285722236884230908714776131247765432042336528688391266197013577846933)
c4=gmpy2.mpz(6322314786528459955624275209917805813977963197598987598299733037650526525624466031785064926679471332366869217573795071766705229938846833708042498920448288027224451566351608238904784133876888583988901715808418961259140738923260100528203650697636525870618113506419591982892872389539566529789994524729918590514568131423130405056881520040257346167912850817773905146357935158291679884759112513574604704311812154185628518329830601133384108588024689978986989088633494277983117641944678806558558378714340619591693860709325444696562395934915362483453221852653125866153852567439630470374248003539319982522672779303126475181188)
n4=gmpy2.mpz(20690588543759338459201261102131523557602951858621022352768878495764772818047444561085946463647026323512505467898486038702296544581574454427913943957312980485120682984328258470676756700031559606051601837978676090075103759061046354026481363302764050167452089628379324207470363334371464572866980379277784494909108912432265324937412023179282154446352432584206636315270087668925211674657165676558801771127073793675007651877248218291179047124458484980007843300303269623821337776079296736563393494962515203685309350731743104371337237221338067550042391180955737666453436685882807146647050068939961249283782794859263934790927)
c5=gmpy2.mpz(10452264611206380895502461195902725433656172118680546576063176352190498143280223991796803163701460661745134845187220614962921364449201367796955338471765037440220874042395114787982271581830776738390691144987486100141239111423372723973913618454824479871719410558793728692489161028990076055893134844059897955709872329576934483081010347855381370928228817449578316569155242146176370238823659613672081164821975593526831584135104392807903152603947384628823036073859290221667822231015474727554763929603850751964998772786601516069402589290834749031168817177708848092842956048636279041074911720643161822044900177343428606560715)
n5=gmpy2.mpz(16517102081052861630895919001217675526698277369300591711866049102573903641338088651465353677681314133196137354591046807286864279671925133798556675780456365747859903691818373002538419664235941077881320873723974912890141942864109366960284815031822877720076646042209075936969869701929261677727681050077163026469462157471618274966461347360748386423007148375581277546370022280825631242730771828201301160075215196139318450096889249372085484891067811333463883782678293168327177450855394281994969889305548254268708625415414795510941577246484314728636995608221724256782771789486658328851046459586540232884627529177340560416993)
c6=gmpy2.mpz(15438573367980546899411469831262554321716625330473541928737354724764298049318171960158271569777673364866920849136573783206585666248260160754065019455326678340354406024017900626179763765010409693145541405692980988544169474943525240828494497282713662818934621304642089048429151421225432071488547417445294367233127459699981695687657415331820328220442387870876009783049627759453935015306450192243998661088428329553312614066422542767799677107630136457339196300283577052597311349488824243602521325223614379636505576657426573528636441051845280239445351931894671325651957634159913859496443826543994354133713665506727986908570)
n6=gmpy2.mpz(23846860290279092907572444079539617462214354239782236629759070773513973525414800313619141664302186747496495971163746242055682769265827639472645512416038516482082192479180022255538780293810541273933187169499865844979861261417193700451844441299094590593715164464011149534562230605044072398232865628048059788633187389023568417475139388654021193716658660041159730755563837795152394878078579534655463322616283839623641180779934135529522581271802799149690558550140547741565135720412155964520008772101738405928224251101453422360053273769367642925204442743550811319417756071808630071840203875705299338612909277917097442575231)
c7=gmpy2.mpz(8050632003496012891153660798070780027719738794256954985992915770053602863453005055350358381780089932811574479914209141251763293880773424963383028351880909610859952262688095044881070279609660956602441745617794173772550768062455391960270824061568535639800037598744981137701020188496515289423994828915238860188040811093385432747166745826277956137865412724288301386616999942392962665743937821657882033976833177184653429865052651102788065404222001648408946611576155822623613313600852649519715691293818195654498470256026193205722239745209050196158652093305973211296246508189057337339578117639605948839837432601701187204691)
n7=gmpy2.mpz(17566701282456258503708647404558041579376753416636895921624574676679101724033623273314113990594123807428022978359642275344892917569831939503189948668240865309669039814491983430907110218013111893576410298548024847128844676202137898746346628853860982276196072572409817530124631239728733042716676159813363682748753083182297029995941313117294252250686136554964244869449490234400819447482806975167157303480233831491591302798414444021786972185652092240434726936513164112181591526851025405006672553646267337903731497655811302924232073336996144108764372355652364792853587376409404275388013071072585640297921892859159400948323)
c8=gmpy2.mpz(13848299090243105393769023620431119607281293241859534330398165884690680599940489251703001966380965437760250480654675951417035797292277289104310749112567702937207419147274538915929482667581044153580987253488834126403487037359201585075003644486768474663768966782093576206949406988705430890998013000643530464156810935974991471956372086991159943728621017385758022429378371761944717268461477739831712045989207822081408017688999813854876855444100019554143123575105414543233058419572336410450148695012711773255272241266524545690968949872835483511020846011863309353131143892382960011655677079795896125188075865350902728475829)
n8=gmpy2.mpz(16253121383768278209005558577055644569117707124854929186667128310606493315013449858902615940095488323028876191616816961215480161502334848550714559842262203333048521009972976254796089176241431933391814530903987798419098078087110325298127023185881308297696190844006356371502958261262318737874080358501446648868436314810687974775378172524379297271535579000788274835896943322448320754626535308836129262616406664292901764961851722791991015882750059327988224491748375219523130042075320130650865135318796823056748272833680628813950407501372466385030092017640922132792751107909729923267741621440199097930132480628796900772029)
c9=gmpy2.mpz(9087335584065643886677005905085431520610790621180029032261173085196586441340442833350933799954596990855629088480007383439883314860651516931486062803257624657331463712585091801767091119951558652391489397231442640048417105309146928731797656572957058431010421428630311710030035284716959029539775615138989235398482150532614129311348288175656759135123815170566468363269665294333672773019537444092595416765925327572876782043880176958395345189241662905356743333635551107596081872736630936229789451719854865254485848063728094286091104342929811927674096850634636056722245699665233189756701937605572188886106463485713932924350)
n9=gmpy2.mpz(20290309021976181378150079070647362877361051642116884020698310582404348426365349349830932277074553597811144356035164416874783743981763606447828375623172664133086570212409720630779251662198484608733581283249766121177416927096509366175689816558284636310339765253094030229680886254669960511903436585522016222678724597374152265027493130428700298457508264585197242398693292101535859643883683283228422929797265173483141156963526966092200813029155535719102888182314267564367377779201639949508213735381237773042753101422482552209042450075752883511314469026255991162957376905635040303277884398802599054812153590799774042488237)
c0=gmpy2.mpz(7129108813208338172682615614908899597774588777053900634433765106802563112210341065108610833283829368416220143397712535640077977797578749504607955975934295166300532962861241889433996968591562514204762466679684186696328022662745703218557540046710480018241836268253785322784547276264603062346623843832348121461734170339554499778193537786872114000844575107065981074981099035588847149758676597493961543224906405302424834687723627561414991846631920995284124914943078135153882676538032551146420612908453105216224113236672710347727600498614794859671483939821190228902865114157203089512138413555411556846607779600435040575270)
n0=gmpy2.mpz(20259407522505114352438066790031189161692762499783918150615320203040060613651670031363001854418241949806197697617226051714447759568062273100011096875597755138510617995005919992091359670438072021331669362289193281360914280630669617706120960853381676622726602146361520387706665131232782238093270978205858281738902665202342179262150897459523695977783336806799817685658837013961068870176413359582541169367864085705134004595535049333058874635763188301138178673153768451934569823185195476045661392099691197429028316750422385531970917919762595412998928711638811089289412827922269444823536467731873971772055257114762319315393
)
e=19
M = n1*n2*n3*n4*n5*n6*n7*n8*n9*n0
m1 = M//n1
m2 = M//n2
m3 = M//n3
m4 = M//n4
m5 = M//n5
m6 = M//n6
m7 = M//n7
m8 = M//n8
m9 = M//n9
m0 = M//n0
t1 = c1*m1*gmpy2.invert(m1,n1)
t2 = c2*m2*gmpy2.invert(m2,n2)
t3 = c3*m3*gmpy2.invert(m3,n3)
t4 = c4*m4*gmpy2.invert(m4,n4)
t5 = c5*m5*gmpy2.invert(m5,n5)
t6 = c6*m6*gmpy2.invert(m6,n6)
t7 = c7*m7*gmpy2.invert(m7,n7)
t8 = c8*m8*gmpy2.invert(m8,n8)
t9 = c9*m9*gmpy2.invert(m9,n9)
t0 = c0*m0*gmpy2.invert(m0,n0)
x = (t1+t2+t3+t4+t5+t6+t7+t8+t9+t0) % M
m=gmpy2.iroot(x,e)
print(m)
m1=662299705588369491570774300226395130401670713246643405660245372654196721793141836090981182198026428636805484
print(hex(m1))
m2=0x483173546144735f4234306144636164745f61747461436b5f655f6172655f73616d655f616e645f736d41396c
flag=libnum.n2s(m2)
print(flag)
#print(libnum.n2s())"""
    elif algorithm == "d泄露攻击":
        # 实现其他算法2的解密逻辑
        e = int(params["e"])
        n = int(params["n"])
        d = int(params["d"])
        t = e * d - 1
        s = 0

        while t % 2 == 0:
            s += 1
            t //= 2

        found = False

        for i in range(1, s):
            c1 = powmod(2, powmod(2, i - 1, n) * t, n)
            c2 = powmod(2, powmod(2, i, n) * t, n)
            if c1 != 1 and c1 != (-1 % n) and c2 == 1:
                p = gcd(c1 - 1, n)
                q = n // p
                break

        if p > q:
                p, q = q, p
        decrypted_message = hashlib.md5(str(p).encode()).hexdigest()
    elif algorithm == "dp&dq泄漏攻击":
        c = int(params["c"])
        p = int(params["p"])
        q = int(params["q"])
        dp = int(params["dp"])
        dq = int(params["dq"])
        invp = invert(p, q)
        m1 = powmod(c, dp, p)
        m2 = powmod(c, dq, q)
        m = (((m2 - m1) * invp) % q) * p + m1
        decrypted_message = long_to_bytes(m),m
    elif algorithm == "Rabin算法":
        # 实现其他算法2的解密逻辑
        hhh = int(params["input number get wp"])



        decrypted_message = """def rabin_attack(c, n, p, q):
    c1 = powmod(c, (p+1)//4, p)
    c2 = powmod(c, (q+1)//4, q)
    cp1 = p - c1
    cp2 = q - c2

    t1 = invert(p, q)
    t2 = invert(q, p)

    m1 = (q*c1*c2 + p*c2*t1) % n
    m2 = (q*c1*t2 + p*cp2*t1) % n
    m3 = (q*cp1*t2 + p*c2*t1) % n
    m4 = (q*cp1*t2 + p*cp2*t1) % n

    return m1, m2, m3, m4

ms = rabin_attack(c, p*q, p, q)

for m in ms:
    print(long_to_bytes(m))"""
    elif algorithm == "RSA3":
        c = int(params["c"])
        e = int(params["e"])
        n = int(params["n"])
        p = int(params["p"])
        q = int(params["q"])
        phi = (p - 1) * (q - 1)
        d = inverse(e, phi)
        m = pow(c, d, n)
        decrypted_message =long_to_bytes(m),m
    else:
        decrypted_message = ""

    return decrypted_message

def get_algorithm_params_info(algorithm):
    # 返回算法需要的参数信息，具体实现需要根据实际情况
    if algorithm == "RSA1":
        return {"c": "整数", "d": "整数", "n": "整数"}
    elif algorithm == "RSA2":
        return {"c": "整数", "e": "整数", "n": "整数"}
    elif algorithm == "RSA3":
        return {"c": "整数", "e": "整数", "n": "整数", "p": "整数", "q": "整数"}
    elif algorithm == "共享素数":
        return {"m1": "整数", "m2": "整数", "c": "整数", "e": "整数"}
    elif algorithm == "共模攻击":
        return {"c1": "整数", "c2": "整数","e1": "整数","e2": "整数","n": "整数",}
    elif algorithm == "e过小":
        return {"n": "类型3", "e": "类型4","c": "类型4"}
    elif algorithm == "pq接近":
        return {"n": "整数", "e": "整数","c": "整数"}
    elif algorithm == "e过大的dp泄露(m=getPrime(64))(10007)":
        return {"n": "整数", "e": "类型4","c": "类型4","dp": "类型4","m": "类型4"}
    elif algorithm == "dp泄露":
        return {"n": "类型3", "e": "类型4","c": "类型4","dp": "类型4"}
    elif algorithm == "维纳攻击":
        return {"n": "类型3", "e": "类型4","c": "类型4"}
    elif algorithm == "e_phi不互素":
        return {"n": "类型3", "e": "类型4","c": "类型4","p": "类型4","q": "类型4"}
    elif algorithm == "p-1光滑":
        return {"n": "类型3", "e": "类型4","c": "类型4"}
    elif algorithm == "p+1光滑":
        return {"n": "类型3", "e": "类型4","c": "类型4"}
    elif algorithm == "小明文攻击":
        return {"n": "类型3", "e": "类型4","c": "类型4"}
    elif algorithm == "低密度广播攻击":
        return {"input number get wp": "类型3"}

    elif algorithm == "d泄露攻击":
        return {"n": "类型3", "e": "类型4","d": "类型4"}
    elif algorithm == "dp&dq泄漏攻击":
        return {"c": "类型3", "p": "类型4","q": "类型4","dp": "类型4","dq": "类型4"}
    elif algorithm == "Rabin算法":
        return {"input number get wp": "类型3"}
    else:
        return {}

if __name__ == "__main__":
    root = tk.Tk()
    root.geometry('800x480')
    app = RSADecryptionGUI(root)
    root.mainloop()
